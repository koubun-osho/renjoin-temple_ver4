/**
 * 蓮城院公式サイト - Web Vitals監視コンポーネント
 *
 * クライアントサイドでCore Web Vitalsを測定・送信
 * パフォーマンス改善のための詳細なメトリクス収集
 *
 * @created 2025-09-18
 * @version 1.0.0 Performance Optimization版
 * @task P4-04 - パフォーマンス最適化
 */

'use client'

import { useEffect, useRef } from 'react'

// ========================
// 型定義
// ========================

interface WebVitalMetric {
  name: 'CLS' | 'FID' | 'FCP' | 'LCP' | 'TTFB' | 'INP'
  value: number
  rating: 'good' | 'needs-improvement' | 'poor'
  delta: number
  entries: PerformanceEntry[]
  id: string
  navigationType: 'navigate' | 'reload' | 'back-forward' | 'prerender'
}

interface PerformanceData {
  url: string
  userAgent: string
  connectionType?: string
  timestamp: number
  metrics: WebVitalMetric[]
  additionalData?: {
    deviceType?: 'mobile' | 'tablet' | 'desktop'
    viewport?: { width: number; height: number }
    loadTime?: number
    domContentLoaded?: number
    firstPaint?: number
    largestContentfulPaint?: number
  }
}

// ========================
// デバイス判定
// ========================

function getDeviceType(): 'mobile' | 'tablet' | 'desktop' {
  if (typeof window === 'undefined') return 'desktop'

  const width = window.innerWidth
  const userAgent = navigator.userAgent

  if (/Mobi|Android/i.test(userAgent) || width < 768) {
    return 'mobile'
  } else if (width < 1024) {
    return 'tablet'
  } else {
    return 'desktop'
  }
}

/**
 * 接続タイプを取得
 */
function getConnectionType(): string {
  if (typeof navigator === 'undefined') return 'unknown'

  // @ts-expect-error - navigator.connection は実験的API
  const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection

  if (connection) {
    return connection.effectiveType || connection.type || 'unknown'
  }

  return 'unknown'
}

/**
 * 追加のパフォーマンスデータを収集
 */
function getAdditionalPerformanceData() {
  if (typeof window === 'undefined' || !window.performance) return {}

  const timing = window.performance.timing
  const navigation = window.performance.navigation

  const data = {
    deviceType: getDeviceType(),
    viewport: {
      width: window.innerWidth,
      height: window.innerHeight
    },
    loadTime: timing.loadEventEnd - timing.navigationStart,
    domContentLoaded: timing.domContentLoadedEventEnd - timing.navigationStart,
    firstPaint: 0,
    largestContentfulPaint: 0
  }

  // Paint Timing API
  if (window.performance.getEntriesByType) {
    const paintEntries = window.performance.getEntriesByType('paint')
    const firstPaint = paintEntries.find(entry => entry.name === 'first-paint')
    const firstContentfulPaint = paintEntries.find(entry => entry.name === 'first-contentful-paint')

    if (firstPaint) data.firstPaint = firstPaint.startTime
  }

  // LCP を個別に取得
  if (window.PerformanceObserver) {
    try {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries()
        const lastEntry = entries[entries.length - 1]
        if (lastEntry) {
          data.largestContentfulPaint = lastEntry.startTime
        }
      })
      observer.observe({ entryTypes: ['largest-contentful-paint'] })

      // 10秒後にオブザーバーを停止
      setTimeout(() => observer.disconnect(), 10000)
    } catch (error) {
      console.warn('LCP monitoring failed:', error)
    }
  }

  return data
}

// ========================
// Web Vitals計測
// ========================

/**
 * メトリクスの評価を計算
 */
function getRating(metricName: string, value: number): 'good' | 'needs-improvement' | 'poor' {
  const thresholds = {
    CLS: { good: 0.1, poor: 0.25 },
    FID: { good: 100, poor: 300 },
    FCP: { good: 1800, poor: 3000 },
    LCP: { good: 2500, poor: 4000 },
    TTFB: { good: 800, poor: 1800 },
    INP: { good: 200, poor: 500 }
  } as const

  const threshold = thresholds[metricName as keyof typeof thresholds]
  if (!threshold) return 'poor'

  if (value <= threshold.good) return 'good'
  if (value <= threshold.poor) return 'needs-improvement'
  return 'poor'
}

/**
 * Web Vitalsデータを送信
 */
async function sendWebVitalsData(metrics: WebVitalMetric[]) {
  if (metrics.length === 0) return

  const data: PerformanceData = {
    url: window.location.href,
    userAgent: navigator.userAgent,
    connectionType: getConnectionType(),
    timestamp: Date.now(),
    metrics,
    additionalData: getAdditionalPerformanceData()
  }

  try {
    const response = await fetch('/api/analytics/web-vitals', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data)
    })

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    const result = await response.json()

    // 開発環境でのデバッグ情報
    if (process.env.NODE_ENV === 'development') {
      console.log('Web Vitals sent successfully:', {
        metrics: metrics.map(m => `${m.name}: ${m.value} (${m.rating})`),
        analysis: result.analysis
      })
    }

  } catch (error) {
    console.warn('Failed to send Web Vitals data:', error)
  }
}

/**
 * Core Web Vitalsを測定
 */
function measureWebVitals() {
  if (typeof window === 'undefined' || !window.PerformanceObserver) {
    console.warn('PerformanceObserver is not supported')
    return
  }

  const metrics: WebVitalMetric[] = []

  // Cumulative Layout Shift (CLS)
  try {
    const clsObserver = new PerformanceObserver((list) => {
      let clsValue = 0
      for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += (entry as any).value
        }
      }

      if (clsValue > 0) {
        metrics.push({
          name: 'CLS',
          value: clsValue,
          rating: getRating('CLS', clsValue),
          delta: clsValue,
          entries: list.getEntries(),
          id: 'cls-' + Date.now(),
          navigationType: (performance.navigation?.type === 1 ? 'reload' : 'navigate') as any
        })
      }
    })

    clsObserver.observe({ entryTypes: ['layout-shift'] })
  } catch (error) {
    console.warn('CLS measurement failed:', error)
  }

  // First Input Delay (FID)
  try {
    const fidObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        const fidValue = entry.processingStart - entry.startTime

        metrics.push({
          name: 'FID',
          value: fidValue,
          rating: getRating('FID', fidValue),
          delta: fidValue,
          entries: [entry],
          id: 'fid-' + Date.now(),
          navigationType: 'navigate'
        })
      }
    })

    fidObserver.observe({ entryTypes: ['first-input'] })
  } catch (error) {
    console.warn('FID measurement failed:', error)
  }

  // Largest Contentful Paint (LCP)
  try {
    const lcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      const lastEntry = entries[entries.length - 1]

      if (lastEntry) {
        const lcpValue = lastEntry.startTime

        metrics.push({
          name: 'LCP',
          value: lcpValue,
          rating: getRating('LCP', lcpValue),
          delta: lcpValue,
          entries: entries,
          id: 'lcp-' + Date.now(),
          navigationType: 'navigate'
        })
      }
    })

    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] })
  } catch (error) {
    console.warn('LCP measurement failed:', error)
  }

  // First Contentful Paint (FCP)
  try {
    const fcpObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.name === 'first-contentful-paint') {
          const fcpValue = entry.startTime

          metrics.push({
            name: 'FCP',
            value: fcpValue,
            rating: getRating('FCP', fcpValue),
            delta: fcpValue,
            entries: [entry],
            id: 'fcp-' + Date.now(),
            navigationType: 'navigate'
          })
        }
      }
    })

    fcpObserver.observe({ entryTypes: ['paint'] })
  } catch (error) {
    console.warn('FCP measurement failed:', error)
  }

  // Time to First Byte (TTFB)
  if (window.performance && window.performance.timing) {
    const navigationStart = window.performance.timing.navigationStart
    const responseStart = window.performance.timing.responseStart
    const ttfbValue = responseStart - navigationStart

    if (ttfbValue > 0) {
      metrics.push({
        name: 'TTFB',
        value: ttfbValue,
        rating: getRating('TTFB', ttfbValue),
        delta: ttfbValue,
        entries: [],
        id: 'ttfb-' + Date.now(),
        navigationType: 'navigate'
      })
    }
  }

  // 5秒後にデータを送信（メトリクス収集の完了を待つ）
  setTimeout(() => {
    if (metrics.length > 0) {
      sendWebVitalsData(metrics)
    }
  }, 5000)

  // ページアンロード時にも送信
  window.addEventListener('beforeunload', () => {
    if (metrics.length > 0) {
      // navigator.sendBeacon を使用してデータを確実に送信
      const data = JSON.stringify({
        url: window.location.href,
        userAgent: navigator.userAgent,
        connectionType: getConnectionType(),
        timestamp: Date.now(),
        metrics,
        additionalData: getAdditionalPerformanceData()
      })

      if (navigator.sendBeacon) {
        navigator.sendBeacon('/api/analytics/web-vitals', data)
      }
    }
  })
}

// ========================
// React コンポーネント
// ========================

/**
 * Web Vitals監視コンポーネント
 */
export const WebVitalsMonitor = () => {
  const initialized = useRef(false)

  useEffect(() => {
    // 重複実行を防ぐ
    if (initialized.current) return
    initialized.current = true

    // ページロード完了後に測定開始
    if (document.readyState === 'complete') {
      measureWebVitals()
    } else {
      window.addEventListener('load', measureWebVitals)
    }

    return () => {
      window.removeEventListener('load', measureWebVitals)
    }
  }, [])

  // このコンポーネントは何もレンダリングしない
  return null
}

// ========================
// 手動測定用のヘルパー関数
// ========================

/**
 * 手動でパフォーマンス測定を実行
 */
export const measurePerformance = () => {
  if (typeof window !== 'undefined') {
    measureWebVitals()
  }
}

/**
 * 現在のWeb Vitalsメトリクスを取得
 */
export const getCurrentMetrics = (): Promise<WebVitalMetric[]> => {
  return new Promise((resolve) => {
    const metrics: WebVitalMetric[] = []

    // 現在利用可能なメトリクスを即座に取得
    if (window.performance && window.performance.timing) {
      const timing = window.performance.timing
      const navigationStart = timing.navigationStart

      // TTFB
      if (timing.responseStart > navigationStart) {
        const ttfbValue = timing.responseStart - navigationStart
        metrics.push({
          name: 'TTFB',
          value: ttfbValue,
          rating: getRating('TTFB', ttfbValue),
          delta: ttfbValue,
          entries: [],
          id: 'ttfb-current',
          navigationType: 'navigate'
        })
      }
    }

    resolve(metrics)
  })
}

export default WebVitalsMonitor